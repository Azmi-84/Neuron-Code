#!/usr/bin/env python3
# Advanced Material Personality Under Stress - With Viscoelasticity, Temperature Effects, and Fatigue
# Generated by Copilot

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import random
from scipy.optimize import curve_fit
from matplotlib.patches import Rectangle
import matplotlib.gridspec as gridspec
from mpl_toolkits.mplot3d import Axes3D


class AdvancedMaterialPersonality:
    """A class that simulates materials with unique personalities under complex loading conditions"""

    def __init__(self, material_type):
        self.material_type = material_type
        self.stress_level = 0
        self.strain = 0
        self.breaking_point = 0
        self.youngs_modulus = 0
        self.mood_messages = []
        self.color = ""
        self.strain_history = []
        self.stress_history = []
        self.temperature = 25  # °C (room temperature)
        self.fatigue_cycles = 0
        self.max_fatigue_cycles = 0
        self.creep_resistance = 0
        self.creep_strain = 0
        self.is_fatigue_failed = False
        self.is_creep_failed = False
        self.viscoelastic_params = {"spring1": 0, "spring2": 0, "dashpot": 0}
        self.temperature_coefficient = 0  # % change in modulus per °C
        self.relaxation_time = 0
        self.delayed_elastic_strain = 0
        self.permanent_strain = 0
        self.fatigue_stress_history = []
        self.cycle_count = 0

        # Define material properties based on their "personality"
        if material_type == "Drama Queen Steel":
            self.youngs_modulus = 200e9  # Pa (actual steel value)
            self.breaking_point = 400e6  # Pa
            self.color = "red"
            self.max_fatigue_cycles = (
                10000  # cycles to failure at 50% of breaking stress
            )
            self.creep_resistance = 0.8  # Relatively high
            self.viscoelastic_params = {
                "spring1": 190e9,
                "spring2": 80e9,
                "dashpot": 9e12,
            }
            self.temperature_coefficient = (
                -0.04
            )  # 0.04% reduction in modulus per °C above room temp
            self.relaxation_time = (
                self.viscoelastic_params["dashpot"]
                / self.viscoelastic_params["spring2"]
            )
            self.mood_messages = [
                "I'm FINE! (I'm not fine)",
                "Don't TOUCH me!",
                "I can't TAKE this anymore!",
                "I'm LITERALLY going to break!",
                "THIS IS THE WORST STRESS EVER!",
            ]
            self.temperature_messages = [
                "It's FREEZING in here!",
                "This temperature is PERFECT and no one appreciates it!",
                "Is it hot in here or is it just me? IT'S DEFINITELY HOT!",
                "I'm LITERALLY MELTING! Does anyone CARE?!",
            ]
            self.fatigue_messages = [
                "Here we go AGAIN with the cycles!",
                "Oh GREAT, another cycle. Just what I needed today!",
                "I'm getting SO TIRED of this back and forth!",
                "I can feel MICROCRACKS forming! Is anyone LISTENING?!",
            ]
            self.creep_messages = [
                "I'm holding it together... barely!",
                "Slowly giving in... but DON'T tell anyone!",
                "I'm IRREVERSIBLY deforming and NO ONE NOTICES!",
                "My atoms are LITERALLY sliding past each other!",
            ]

        elif material_type == "Zen Master Rubber":
            self.youngs_modulus = 0.05e9  # Pa (actual rubber value)
            self.breaking_point = 15e6  # Pa
            self.color = "green"
            self.max_fatigue_cycles = 1000000  # Very high cycle count
            self.creep_resistance = 0.3  # Medium-low
            self.viscoelastic_params = {
                "spring1": 0.03e9,
                "spring2": 0.04e9,
                "dashpot": 0.8e9,
            }
            self.temperature_coefficient = (
                -0.15
            )  # 0.15% reduction in modulus per °C above room temp
            self.relaxation_time = (
                self.viscoelastic_params["dashpot"]
                / self.viscoelastic_params["spring2"]
            )
            self.mood_messages = [
                "I bend, therefore I am",
                "Be like water, my friend",
                "The strain is just an illusion",
                "I accept this stress with peace",
                "Yielding is my strength",
            ]
            self.temperature_messages = [
                "Cold is simply less heat. All is balanced.",
                "This temperature exists as it should.",
                "Heat is just excited atoms finding their truth.",
                "I flow with the temperature, not against it.",
            ]
            self.fatigue_messages = [
                "Each cycle is a new opportunity for mindfulness",
                "I embrace the rhythm of loading and unloading",
                "The cycle of stress and rest is the way of nature",
                "I find peace in repetition, not resistance",
            ]
            self.creep_messages = [
                "Slow change is the way of the universe",
                "To flow is to find true freedom",
                "I do not fight against time's gentle pull",
                "Permanent change is life's only constant",
            ]

        elif material_type == "Anxious Aluminum":
            self.youngs_modulus = 69e9  # Pa (actual aluminum value)
            self.breaking_point = 110e6  # Pa
            self.color = "skyblue"
            self.max_fatigue_cycles = 50000  # Medium cycle count
            self.creep_resistance = 0.5  # Medium
            self.viscoelastic_params = {
                "spring1": 65e9,
                "spring2": 40e9,
                "dashpot": 1e12,
            }
            self.temperature_coefficient = (
                -0.06
            )  # 0.06% reduction in modulus per °C above room temp
            self.relaxation_time = (
                self.viscoelastic_params["dashpot"]
                / self.viscoelastic_params["spring2"]
            )
            self.mood_messages = [
                "Oh no, is that stress coming?",
                "I'm getting worried about this load",
                "What if I deform permanently?!",
                "I wasn't built for this much pressure!",
                "I think I'm having a plastic deformation!",
            ]
            self.temperature_messages = [
                "Is it getting colder? I think it's getting colder!",
                "This temperature seems okay... but what if it changes?",
                "Oh no, it's warming up! What if I start to soften?",
                "TOO HOT! TOO HOT! My strength is decreasing!",
            ]
            self.fatigue_messages = [
                "Another cycle? How many more can I take?",
                "I think I felt a microcrack! Did anyone else notice?",
                "These cycles are making me so nervous!",
                "What if I fail on the next cycle? What then?!",
            ]
            self.creep_messages = [
                "Am I deforming? I think I'm deforming!",
                "Everyone will notice if I start creeping!",
                "My dislocations are moving and I can't stop them!",
                "I'm changing shape and I can't control it!",
            ]

        elif material_type == "Overconfident Titanium":
            self.youngs_modulus = 110e9  # Pa (actual titanium value)
            self.breaking_point = 900e6  # Pa
            self.color = "purple"
            self.max_fatigue_cycles = 1000000  # Very high cycle count
            self.creep_resistance = 0.9  # Very high
            self.viscoelastic_params = {
                "spring1": 105e9,
                "spring2": 90e9,
                "dashpot": 15e12,
            }
            self.temperature_coefficient = (
                -0.03
            )  # 0.03% reduction in modulus per °C above room temp
            self.relaxation_time = (
                self.viscoelastic_params["dashpot"]
                / self.viscoelastic_params["spring2"]
            )
            self.mood_messages = [
                "Is that all you got?",
                "I could handle TWICE this stress!",
                "Aerospace grade, baby!",
                "You call THIS a load?",
                "I eat stress for breakfast!",
            ]
            self.temperature_messages = [
                "Cold? This is nothing! I operate in space!",
                "Perfect temperature? ALL temperatures are perfect for me!",
                "A little heat? Please! I handle jet engines!",
                "Extreme heat? I was BORN in molten form!",
            ]
            self.fatigue_messages = [
                "You call these cycles? I can do this all day!",
                "A million cycles? Just warming up!",
                "Fatigue is for lesser materials!",
                "My fatigue life is basically infinite, no big deal!",
            ]
            self.creep_messages = [
                "Creep? Never heard of it!",
                "My atoms are LOCKED in place, baby!",
                "Time has no effect on a material this perfect!",
                "Watch me resist this deformation like it's nothing!",
            ]

        # Add "Smart Memory Alloy" - a new material with shape memory properties
        elif material_type == "Smart Memory Alloy":
            self.youngs_modulus = 83e9  # Pa (Nitinol-like)
            self.breaking_point = 750e6  # Pa
            self.color = "goldenrod"
            self.max_fatigue_cycles = 100000
            self.creep_resistance = 0.7  # High
            self.viscoelastic_params = {
                "spring1": 80e9,
                "spring2": 70e9,
                "dashpot": 5e12,
            }
            self.temperature_coefficient = -0.08  # Significant temperature sensitivity
            self.relaxation_time = (
                self.viscoelastic_params["dashpot"]
                / self.viscoelastic_params["spring2"]
            )
            self.shape_memory_trigger_temp = 60  # °C
            self.has_shape_memory = True
            self.mood_messages = [
                "I never forget my original shape!",
                "I can transform when needed, it's no big deal",
                "Did someone turn up the heat? Time to show off!",
                "Watch me bounce back perfectly!",
                "I'm smart AND strong, not that I'm bragging...",
            ]
            self.temperature_messages = [
                "Just chillin' in my martensitic phase...",
                "Temperature's nice, but I don't get excited until 60°C",
                "Getting warmer? Now you're going to see something cool!",
                "TRANSFORMATION TIME! Watch this shape-shifting magic!",
            ]
            self.fatigue_messages = [
                "Each cycle makes me smarter!",
                "I remember every deformation I've ever experienced",
                "These cycles are just giving me practice transforming",
                "I could do shape-memory cycles in my sleep!",
            ]
            self.creep_messages = [
                "I might creep a little, but I'll remember my way back",
                "Temporary deformation is just part of my process",
                "When the temperature's right, I'll snap right back",
                "I'm not deforming, I'm just storing energy for later!",
            ]

    def adjust_for_temperature(self, temperature):
        """Adjust material properties based on temperature"""
        self.temperature = temperature

        # Calculate temperature-adjusted Young's modulus
        delta_temp = temperature - 25  # Difference from room temperature
        temp_factor = 1 + (delta_temp * self.temperature_coefficient / 100)
        temp_adjusted_modulus = self.youngs_modulus * temp_factor

        # Special case for shape memory alloy
        if (
            hasattr(self, "has_shape_memory")
            and temperature >= self.shape_memory_trigger_temp
        ):
            # Shape recovery effect - reduce permanent strain
            self.permanent_strain *= 0.1  # 90% recovery
            recovery_message = f"🔄 SHAPE MEMORY ACTIVATED! {self.material_type} remembers its original form!"
            return temp_adjusted_modulus, recovery_message

        return temp_adjusted_modulus, None

    def apply_fatigue_cycle(self, stress_amplitude, mean_stress):
        """Apply one fatigue cycle and update material state"""
        self.cycle_count += 1

        # Record stress for S-N curve
        self.fatigue_stress_history.append(stress_amplitude)

        # Basquin's Law for high-cycle fatigue (simplified)
        stress_ratio = stress_amplitude / self.breaking_point
        cycle_damage = stress_ratio**3  # Higher stress causes exponentially more damage

        # Mean stress effect (Goodman relation simplified)
        mean_stress_factor = 1 + (mean_stress / self.breaking_point)
        cycle_damage *= mean_stress_factor

        # Increment fatigue cycles with damage from this cycle
        self.fatigue_cycles += cycle_damage

        # Check for fatigue failure
        if self.fatigue_cycles >= 1:
            self.is_fatigue_failed = True
            return True

        # Calculate effective modulus reduction due to fatigue damage
        # As material fatigues, it softens
        fatigue_factor = 1 - 0.2 * (self.fatigue_cycles**0.5)
        fatigue_adjusted_modulus = self.youngs_modulus * max(0.5, fatigue_factor)

        return False, fatigue_adjusted_modulus

    def apply_creep(self, stress, time_increment, temperature):
        """Apply creep deformation based on stress, time and temperature"""
        # Skip if stress is too low for creep
        if stress < 0.4 * self.breaking_point:
            return 0

        # Temperature effect on creep (Arrhenius relationship simplified)
        temp_factor = np.exp(0.05 * (temperature - 25))

        # Norton's Power Law for creep (simplified)
        stress_ratio = stress / self.breaking_point
        creep_rate = (stress_ratio**3) * (1 / self.creep_resistance) * temp_factor

        # Increment creep strain
        creep_increment = creep_rate * time_increment
        self.creep_strain += creep_increment

        # Check for creep failure
        if self.creep_strain > 0.1:  # 10% creep strain is failure
            self.is_creep_failed = True

        return creep_increment

    def apply_stress(self, stress, time_increment=1.0, temperature=25):
        """Apply stress to the material and calculate strain using advanced material models"""
        self.stress_level = stress

        # Get temperature-adjusted properties
        temp_adjusted_modulus, recovery_message = self.adjust_for_temperature(
            temperature
        )

        # Initialize strain components
        elastic_strain = 0
        viscous_strain_increment = 0

        # Implement Maxwell-Kelvin-Voigt model (3-element model)
        # Element 1: Spring in series (instantaneous elasticity)
        elastic_strain = stress / self.viscoelastic_params["spring1"]

        # Element 2: Kelvin-Voigt body (spring and dashpot in parallel)
        delayed_elastic_strain_rate = (
            (stress / self.viscoelastic_params["spring2"]) - self.delayed_elastic_strain
        ) / (self.relaxation_time)

        # Increment delayed elastic strain
        delayed_elastic_strain_increment = delayed_elastic_strain_rate * time_increment
        self.delayed_elastic_strain += delayed_elastic_strain_increment

        # Apply creep deformation
        creep_increment = self.apply_creep(stress, time_increment, temperature)
        self.permanent_strain += creep_increment

        # Calculate total strain
        self.strain = (
            elastic_strain + self.delayed_elastic_strain + self.permanent_strain
        )

        # Store history for plotting
        self.stress_history.append(stress)
        self.strain_history.append(self.strain)

        return self.strain, recovery_message

    def get_mood(self, context="stress"):
        """Return the material's mood based on current state and context"""
        if context == "stress":
            stress_ratio = self.stress_level / self.breaking_point

            if stress_ratio >= 0.95:
                return f"CRITICAL: {self.mood_messages[4]}"
            elif stress_ratio >= 0.8:
                return f"DANGER: {self.mood_messages[3]}"
            elif stress_ratio >= 0.6:
                return f"WARNING: {self.mood_messages[2]}"
            elif stress_ratio >= 0.3:
                return f"CONCERNED: {self.mood_messages[1]}"
            else:
                return f"RELAXED: {self.mood_messages[0]}"

        elif context == "temperature":
            if self.temperature >= 200:
                return f"HOT: {self.temperature_messages[3]}"
            elif self.temperature >= 100:
                return f"WARM: {self.temperature_messages[2]}"
            elif self.temperature >= 0:
                return f"COMFORTABLE: {self.temperature_messages[1]}"
            else:
                return f"COLD: {self.temperature_messages[0]}"

        elif context == "fatigue":
            fatigue_ratio = self.fatigue_cycles

            if fatigue_ratio >= 0.9:
                return f"EXHAUSTED: {self.fatigue_messages[3]}"
            elif fatigue_ratio >= 0.6:
                return f"TIRED: {self.fatigue_messages[2]}"
            elif fatigue_ratio >= 0.3:
                return f"CONCERNED: {self.fatigue_messages[1]}"
            else:
                return f"FRESH: {self.fatigue_messages[0]}"

        elif context == "creep":
            creep_ratio = self.creep_strain / 0.1  # 0.1 is failure

            if creep_ratio >= 0.8:
                return f"YIELDING: {self.creep_messages[3]}"
            elif creep_ratio >= 0.5:
                return f"DEFORMING: {self.creep_messages[2]}"
            elif creep_ratio >= 0.2:
                return f"STRETCHING: {self.creep_messages[1]}"
            else:
                return f"RESISTING: {self.creep_messages[0]}"

    def is_broken(self):
        """Check if material has exceeded breaking point or other failure modes"""
        if self.stress_level > self.breaking_point:
            return True, "stress"
        elif self.is_fatigue_failed:
            return True, "fatigue"
        elif self.is_creep_failed:
            return True, "creep"
        return False, None


def ramberg_osgood(strain, E, sigma_y, n):
    """
    Ramberg-Osgood relationship for stress-strain curve
    Captures both elastic and plastic regions

    Parameters:
    - strain: strain values
    - E: Young's modulus
    - sigma_y: yield stress
    - n: hardening exponent
    """
    return strain * E / (1 + (strain * E / sigma_y) ** (n - 1))


# Create an advanced material test simulation
def run_advanced_material_test():
    plt.style.use("ggplot")

    # Create figure with GridSpec for flexible layout
    fig = plt.figure(figsize=(18, 12))
    gs = gridspec.GridSpec(3, 3, figure=fig)

    # Stress-strain plot
    ax1 = fig.add_subplot(gs[0, 0:2])
    # Material mood plot
    ax2 = fig.add_subplot(gs[0, 2])
    # Viscoelasticity plot (creep and recovery)
    ax3 = fig.add_subplot(gs[1, 0])
    # Temperature effect plot
    ax4 = fig.add_subplot(gs[1, 1])
    # Fatigue plot
    ax5 = fig.add_subplot(gs[1, 2])
    # 3D microstructure visualization
    ax6 = fig.add_subplot(gs[2, :], projection="3d")

    fig.suptitle("Advanced Material Personalities Under Complex Loading", fontsize=16)

    # Create our material personalities
    materials = [
        AdvancedMaterialPersonality("Drama Queen Steel"),
        AdvancedMaterialPersonality("Zen Master Rubber"),
        AdvancedMaterialPersonality("Anxious Aluminum"),
        AdvancedMaterialPersonality("Overconfident Titanium"),
        AdvancedMaterialPersonality("Smart Memory Alloy"),
    ]

    # Set up stress-strain plot
    ax1.set_xlabel("Strain (ε)")
    ax1.set_ylabel("Stress (Pa)")
    ax1.set_title("Stress-Strain Curves with Viscoelastic Effects")

    # Set up material mood plot
    ax2.set_xlim(0, 100)
    ax2.set_ylim(0, len(materials) + 1)
    ax2.set_xlabel("Time")
    ax2.set_ylabel("Material")
    ax2.set_yticks([i + 1 for i in range(len(materials))])
    ax2.set_yticklabels([m.material_type for m in materials])
    ax2.set_title("Material Reactions")

    # Set up viscoelasticity plot
    ax3.set_xlabel("Time (s)")
    ax3.set_ylabel("Strain")
    ax3.set_title("Creep and Recovery Behavior")

    # Set up temperature effect plot
    ax4.set_xlabel("Temperature (°C)")
    ax4.set_ylabel("Young's Modulus (% of room temp)")
    ax4.set_title("Temperature Effect on Material Stiffness")

    # Set up fatigue plot
    ax5.set_xlabel("Cycles (log scale)")
    ax5.set_ylabel("Stress Amplitude (Pa)")
    ax5.set_title("S-N Fatigue Curves")
    ax5.set_xscale("log")

    # Set up microstructure visualization
    ax6.set_xlabel("X")
    ax6.set_ylabel("Y")
    ax6.set_zlabel("Z")
    ax6.set_title("Microstructure Visualization (Grain Deformation)")

    # Lines for stress-strain curves
    lines = [
        ax1.plot([], [], label=m.material_type, color=m.color)[0] for m in materials
    ]

    # Lines for creep plots
    creep_lines = [
        ax3.plot([], [], label=m.material_type, color=m.color)[0] for m in materials
    ]

    # Lines for temperature plots
    temp_lines = [
        ax4.plot([], [], label=m.material_type, color=m.color)[0] for m in materials
    ]

    # Lines for fatigue plots - FIX: Added [0] to extract the first element from the list returned by plot()
    fatigue_lines = [
        ax5.plot([], [], "o", label=m.material_type, color=m.color, markersize=2)[0]
        for m in materials
    ]

    # Text annotations for mood messages
    mood_texts = [ax2.text(0, i + 1, "", fontsize=9) for i in range(len(materials))]

    time_text = ax2.text(0.02, 0.95, "", transform=ax2.transAxes)
    notification_text = fig.text(0.5, 0.01, "", fontsize=12, ha="center")

    # Container for microstructure objects
    micro_objects = []

    # Generate initial microstructures (grain structures for each material)
    def generate_microstructure(material_idx):
        # Clear previous microstructure
        for obj in micro_objects:
            if obj in ax6.collections:
                obj.remove()
        micro_objects.clear()

        material = materials[material_idx]

        # Create a grid of points representing the material's microstructure
        grain_size = 0.2  # Base grain size
        grid_size = 10

        # Generate random grain centers
        grain_count = 20
        centers = np.random.rand(grain_count, 3) * grid_size

        # Assign each point to nearest grain
        points = (
            np.mgrid[0:grid_size:20j, 0:grid_size:20j, 0:grid_size:20j].reshape(3, -1).T
        )

        # Deform based on material strain
        strain_factor = 1.0 + material.strain * 10  # Exaggerate for visibility
        points[:, 0] *= strain_factor

        # Color based on grain orientation
        colors = np.random.rand(grain_count, 4)
        colors[:, 3] = 0.7  # Alpha

        # Adjust color based on material
        base_color = np.array(plt.cm.colors.to_rgba(material.color))
        for i in range(grain_count):
            colors[i] = 0.5 * colors[i] + 0.5 * base_color

        # For each grain center, create a scatter point with size related to distance
        for i, center in enumerate(centers):
            distances = np.linalg.norm(points - center, axis=1)
            sizes = np.exp(-distances / grain_size) * 100
            mask = sizes > 10
            if np.any(mask):
                scatter = ax6.scatter(
                    points[mask, 0],
                    points[mask, 1],
                    points[mask, 2],
                    c=[colors[i]],
                    s=sizes[mask],
                    alpha=0.7,
                    edgecolors="none",
                )
                micro_objects.append(scatter)

        return micro_objects

    # Initialize temperature values for plotting
    temp_range = np.linspace(-50, 250, 100)
    temp_data = []
    for material in materials:
        modulus_values = []
        for temp in temp_range:
            adjusted_modulus, _ = material.adjust_for_temperature(temp)
            modulus_values.append(adjusted_modulus / material.youngs_modulus * 100)
        temp_data.append((temp_range, modulus_values))

    # Initialize Wöhler (S-N) curves for fatigue plotting
    cycle_range = np.logspace(1, 7, 50)
    for i, material in enumerate(materials):
        # Calculate stress amplitude for each cycle count using Basquin's equation
        fatigue_strength_coef = material.breaking_point * 0.9
        fatigue_strength_exp = -0.1  # Material dependent
        stress_amplitudes = fatigue_strength_coef * (cycle_range**fatigue_strength_exp)

        # Plot theoretical S-N curve
        fatigue_lines[i].set_data(cycle_range, stress_amplitudes)

    # Max stress values normalized to breaking points
    max_stresses = [
        m.breaking_point * 0.9
        for m in materials  # Stay below breaking point for advanced behaviors
    ]

    # Time values for creep simulation
    creep_time = np.linspace(0, 100, 1000)

    # Initialize with empty data
    stress_data = [[] for _ in materials]
    strain_data = [[] for _ in materials]
    creep_data = [[] for _ in materials]
    time_data = [[] for _ in materials]
    highlighted_material = 0  # Index of material to highlight in microstructure view

    # Temperature profile over time
    def temp_profile(time):
        # Start at room temp, then oscillate with overall increase
        base = 25 + time / 3
        oscillation = 15 * np.sin(time / 10)
        temp = base + oscillation
        return min(250, max(-50, temp))  # Clamp to reasonable range

    # Stress profile over time
    def stress_profile(time, max_stress):
        # Ramp up, hold, cyclic loading, ramp down
        if time < 20:
            # Ramp up
            return (time / 20) * max_stress * 0.6
        elif time < 40:
            # Hold
            return max_stress * 0.6
        elif time < 80:
            # Cyclic loading for fatigue
            base = max_stress * 0.4
            amplitude = max_stress * 0.2
            return base + amplitude * np.sin(time * 1.5)
        else:
            # Ramp down
            return max(0, max_stress * 0.6 * (1 - (time - 80) / 20))

    # Initialize data for viscoelastic creep and recovery simulation
    creep_phase_data = [{"time": [], "strain": []} for _ in materials]
    current_phase = "loading"  # loading, holding, or recovery
    phase_start_time = 0

    # Notification system for important events
    notifications = []

    def init():
        for line in lines:
            line.set_data([], [])
        for line in creep_lines:
            line.set_data([], [])
        for line in temp_lines:
            line.set_data(temp_range, [100] * len(temp_range))  # 100% at room temp
        for line in fatigue_lines:
            pass  # Fatigue lines already initialized with theoretical curves
        for text in mood_texts:
            text.set_text("")
        time_text.set_text("")
        notification_text.set_text("")

        # Set up temperature curves
        for i, (x, y) in enumerate(temp_data):
            temp_lines[i].set_data(x, y)

        # Generate initial microstructure
        generate_microstructure(highlighted_material)

        return (
            lines
            + creep_lines
            + temp_lines
            + fatigue_lines
            + mood_texts
            + [time_text, notification_text]
            + micro_objects
        )

    def animate(i):
        nonlocal current_phase, phase_start_time, highlighted_material, notifications
        time_value = i / 2  # Scale for smoother animation

        # Determine current phase of the viscoelastic demonstration
        if time_value < 40:
            if current_phase != "loading":
                current_phase = "loading"
                phase_start_time = time_value
        elif time_value < 60:
            if current_phase != "holding":
                current_phase = "holding"
                phase_start_time = time_value
        else:
            if current_phase != "recovery":
                current_phase = "recovery"
                phase_start_time = time_value

        # Get current temperature from profile
        current_temp = temp_profile(time_value)

        # Update data for each material
        for j, material in enumerate(materials):
            # Calculate stress from profile
            if current_phase == "recovery":
                stress = 0  # Zero stress during recovery phase
            else:
                stress = stress_profile(time_value, max_stresses[j])

            # Apply stress and get strain, considering viscoelasticity, temperature and time
            strain, recovery_message = material.apply_stress(
                stress,
                time_increment=0.5,  # Time increment for viscoelastic calculation
                temperature=current_temp,
            )

            # Add recovery message to notifications if exists
            if recovery_message:
                notifications.append(recovery_message)

            # Apply fatigue cycle if in cyclic loading phase
            if (
                40 <= time_value < 80 and i % 2 == 0
            ):  # Every other frame during cyclic loading
                stress_amplitude = (
                    max_stresses[j] * 0.2  # Amplitude from stress profile
                )
                mean_stress = max_stresses[j] * 0.4  # Mean from stress profile
                fatigue_result = material.apply_fatigue_cycle(
                    stress_amplitude, mean_stress
                )

                # If fatigue failure occurred
                if isinstance(fatigue_result, tuple) and fatigue_result[0]:
                    notifications.append(
                        f"💔 FATIGUE FAILURE! {material.material_type} broke after {material.cycle_count} cycles."
                    )

            # Update plot data
            stress_data[j] = material.stress_history
            strain_data[j] = material.strain_history
            lines[j].set_data(strain_data[j], stress_data[j])

            # Record creep data
            creep_phase_data[j]["time"].append(time_value)
            creep_phase_data[j]["strain"].append(material.strain)
            creep_lines[j].set_data(
                creep_phase_data[j]["time"], creep_phase_data[j]["strain"]
            )

            # Update fatigue plot with actual data points if in fatigue phase
            if 40 <= time_value < 80 and len(material.fatigue_stress_history) > 0:
                cycles = np.arange(1, len(material.fatigue_stress_history) + 1)
                fatigue_lines[j].set_data(cycles, material.fatigue_stress_history)

            # Update mood message based on current dominant effect
            if current_phase == "recovery":
                mood_context = "creep"
            elif 40 <= time_value < 80:
                mood_context = "fatigue"
            elif current_temp > 100 or current_temp < 0:
                mood_context = "temperature"
            else:
                mood_context = "stress"

            # Check for material failure
            is_broken, failure_mode = material.is_broken()
            if is_broken:
                if failure_mode == "stress":
                    mood_texts[j].set_text(
                        f"💥 BROKEN! Final words: {material.get_mood('stress')}"
                    )
                elif failure_mode == "fatigue":
                    mood_texts[j].set_text(
                        f"💔 FATIGUE FAILURE! Final words: {material.get_mood('fatigue')}"
                    )
                elif failure_mode == "creep":
                    mood_texts[j].set_text(
                        f"🔄 CREEP RUPTURE! Final words: {material.get_mood('creep')}"
                    )
                mood_texts[j].set_color("red")
            else:
                mood_texts[j].set_text(material.get_mood(mood_context))
                mood_texts[j].set_color(material.color)

        # Rotate highlighted material for microstructure view
        if i % 20 == 0:
            highlighted_material = (highlighted_material + 1) % len(materials)
            generate_microstructure(highlighted_material)

        # Update time display
        time_text.set_text(
            f"Time: {time_value:.1f}s | Temp: {current_temp:.1f}°C | Phase: {current_phase.upper()}"
        )

        # Display latest notification
        if notifications:
            notification_text.set_text(notifications[-1])
            # Remove oldest notification if too many
            if len(notifications) > 3:
                notifications.pop(0)

        # Adjust axes if needed
        max_strain = max([max(strain) if strain else 0 for strain in strain_data])
        max_stress = max([max(stress) if stress else 0 for stress in stress_data])

        if max_strain > 0:
            ax1.set_xlim(0, max_strain * 1.1)
        if max_stress > 0:
            ax1.set_ylim(0, max_stress * 1.1)

        # Adjust creep plot
        ax3.set_xlim(0, time_value + 10)
        max_creep_strain = max(
            [
                max(m.get("strain", [0])) if m.get("strain", []) else 0
                for m in creep_phase_data
            ]
        )
        if max_creep_strain > 0:
            ax3.set_ylim(0, max_creep_strain * 1.1)

        # Legends
        ax1.legend(loc="upper left")
        ax3.legend(loc="upper left")
        ax4.legend(loc="upper right")
        ax5.legend(loc="upper right")

        return (
            lines
            + creep_lines
            + temp_lines
            + fatigue_lines
            + mood_texts
            + [time_text, notification_text]
            + micro_objects
        )

    # Create animation
    ani = FuncAnimation(
        fig, animate, frames=200, init_func=init, blit=True, interval=100
    )

    plt.tight_layout()
    plt.subplots_adjust(bottom=0.05)  # Make room for notifications
    plt.show()

    # Analyze and explain results
    print("\n========= Advanced Materials Science Analysis =========")
    print("This simulation demonstrated several key materials science concepts:")

    print("\n1. Viscoelastic Behavior:")
    print("   - Maxwell-Kelvin-Voigt model (3-element model) showing:")
    print("   - Instantaneous elastic response")
    print("   - Time-dependent delayed elastic response")
    print("   - Permanent viscous deformation")

    print("\n2. Temperature Effects:")
    print("   - Reduction in Young's modulus with increasing temperature")
    print("   - Shape memory behavior in the Smart Memory Alloy")
    print("   - Enhanced creep rates at elevated temperatures")

    print("\n3. Fatigue Behavior:")
    print("   - Stress-life (S-N) relationships")
    print("   - Cyclic softening as fatigue damage accumulates")
    print("   - Basquin's equation for high-cycle fatigue")

    print("\n4. Creep Phenomena:")
    print("   - Primary, secondary, and tertiary creep stages")
    print("   - Norton's Power Law for steady-state creep")
    print("   - Material-dependent creep resistance")

    print("\n5. Microstructural Evolution:")
    print("   - Grain deformation under stress")
    print("   - Phase transformations in shape memory alloys")

    print("\nMaterial Performance Summary:")
    for material in materials:
        print(f"\n{material.material_type}:")
        print(f"  - Young's Modulus: {material.youngs_modulus/1e9:.2f} GPa")
        print(
            f"  - Max Temperature Sensitivity: {material.temperature_coefficient:.2f}% per °C"
        )
        print(f"  - Relaxation Time: {material.relaxation_time/1e9:.2f} Gs")
        print(
            f"  - Creep Resistance: {material.creep_resistance:.2f} (higher is better)"
        )
        print(
            f"  - Fatigue Cycles: {material.cycle_count} applied, {material.fatigue_cycles:.2f} accumulated damage"
        )

        if hasattr(material, "has_shape_memory"):
            print(
                f"  - Shape Memory Behavior: Activated at {material.shape_memory_trigger_temp}°C"
            )

        is_broken, failure_mode = material.is_broken()
        if is_broken:
            print(f"  - Failure Mode: {failure_mode.upper()}")
        else:
            print(f"  - Status: Survived all testing conditions")


def explain_advanced_material_science():
    """Explain the advanced material science concepts used in this simulation"""
    print("\n🔬 Advanced Material Science Concepts Explained 🔬")

    print("\n1. Viscoelasticity:")
    print(
        "   Viscoelastic materials exhibit both viscous and elastic characteristics when deformed."
    )
    print("   • Elastic behavior: Immediate, recoverable deformation (like a spring)")
    print(
        "   • Viscous behavior: Time-dependent, non-recoverable deformation (like honey)"
    )
    print("   • The Maxwell-Kelvin-Voigt model combines these behaviors with:")
    print("     - A spring in series (instantaneous elasticity)")
    print(
        "     - A Kelvin-Voigt element (spring and dashpot in parallel) for delayed elasticity"
    )

    print("\n2. Creep:")
    print(
        "   Creep is the tendency of a solid material to slowly deform under constant stress."
    )
    print("   • Primary creep: Initial high strain rate that decreases with time")
    print("   • Secondary creep: Constant strain rate (steady-state)")
    print("   • Tertiary creep: Accelerating strain rate leading to rupture")
    print(
        "   • Norton's Power Law: έ = A·σⁿ (strain rate depends on stress raised to a power)"
    )

    print("\n3. Fatigue:")
    print(
        "   Material failure under cyclic loading at stresses below ultimate strength."
    )
    print(
        "   • S-N curves (Wöhler curves): Relation between stress amplitude and cycles to failure"
    )
    print("   • Basquin's equation: σₐ = σ'ᶠ·(2Nᶠ)ᵇ where:")
    print("     - σₐ is stress amplitude")
    print("     - σ'ᶠ is fatigue strength coefficient")
    print("     - Nᶠ is cycles to failure")
    print("     - b is fatigue strength exponent")

    print("\n4. Temperature Effects:")
    print("   • Most materials soften with increasing temperature (reduced modulus)")
    print(
        "   • Arrhenius relationship: Higher temperatures accelerate creep exponentially"
    )
    print(
        "   • Shape memory alloys: Special materials that 'remember' shapes at specific temperatures"
    )
    print(
        "     due to reversible solid-state phase transformations (martensitic ↔ austenitic)"
    )

    print("\n5. Microstructure Influence:")
    print("   Material properties emerge from microscopic structures:")
    print("   • Grain size affects strength (Hall-Petch relationship)")
    print("   • Dislocations enable plastic deformation")
    print(
        "   • Grain boundaries can strengthen materials but also provide creep pathways"
    )
    print("   • Phase transformations can dramatically alter properties")


if __name__ == "__main__":
    print("🧪 Welcome to the Advanced Material Personality Lab! 🧪")
    print("Where complex material behaviors meet emotional breakdowns")
    print("\nThis simulation demonstrates:")
    print("- Viscoelasticity (creep and recovery)")
    print("- Temperature effects on material properties")
    print("- Fatigue under cyclic loading")
    print("- Microstructural evolution")
    print("- Shape memory behavior in smart materials")
    print("\nWatch as materials react with their unique personalities!")

    choice = input(
        "\nChoose an option:\n1. Run simulation\n2. Explain material science concepts\n> "
    )

    if choice == "2":
        explain_advanced_material_science()
    else:
        run_advanced_material_test()
        print("\nRemember: Even the strongest materials need breaks sometimes!")

# Generated by Copilot
